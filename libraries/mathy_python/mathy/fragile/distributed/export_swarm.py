from collections import deque
import copy
from typing import Tuple

import numpy

from fragile.core import SwarmWrapper
from fragile.core.functions import cross_fai_iteration
from fragile.core.states import States
from fragile.core.swarm import Swarm
from fragile.core.utils import float_type, hash_type, random_state, Scalar, StateDict


class ExportedWalkers(States):
    """Represents the walkers that are being passed across different instances \
    of :class:`ExportSwarm`."""

    def __init__(self, batch_size: int, state_dict: StateDict = None):
        """
        Initialize a :class:`ExportWalkers`.

        Args:
            batch_size: Number of walkers that will be exported.
            state_dict: External :class:`StateDict` that overrides the default values.

        """
        self.id_walkers = None
        self.rewards = None
        self.observs = None
        self.states = None

        # Accept external definition of ExportedWalkers param_dict values
        walkers_dict = self.get_params_dict()
        if state_dict is not None:
            for k, v in state_dict.items():
                if k in walkers_dict:
                    walkers_dict[k] = v
        super(ExportedWalkers, self).__init__(batch_size=batch_size, state_dict=walkers_dict)

    def get_params_dict(self) -> StateDict:
        """Return a dictionary containing the param_dict to build an instance \
        of States that can handle all the data generated by the :class:`Walkers`.
        """
        params = {
            "id_walkers": {"dtype": hash_type},
            "rewards": {"dtype": float_type},
            "observs": {"dtype": float_type},
            "states": {"dtype": float_type},
        }
        return params

    def get_best_index(self, minimize: bool) -> int:
        """
        Return the index of the best walker present in the :class:`ExportedWalkers`.

        Args:
            minimize: If ``True`` return the index of the walker with the lowest \
                      reward. If ``False`` return the index of the walker with \
                      the highest reward.

        Returns:
            Index of the best walker.

        """
        return self.rewards.argmin() if minimize else self.rewards.argmax()

    def get_best_reward(self, minimize: bool) -> Scalar:
        """
        Return the reward value of the best walker present in the \
        :class:`ExportedWalkers`.

        Args:
            minimize: If ``True`` return the lowest reward. If ``False`` return \
            the  highest reward.

        Returns:
            Reward value of the best walker.

        """
        return self.rewards.min() if minimize else self.rewards.max()


class BestWalker(ExportedWalkers):
    """Represent the best walker found during a distributed search process run \
    with several :class:`ExportSwarm`."""

    def __init__(self, minimize: bool = False):
        """
        Initialize a :class:`BestWalker`.

        Args:
            minimize: If ``True`` the walker represents a minimization process.
        """
        super(BestWalker, self).__init__(1)
        self.minimize = minimize

    def update_best(self, walkers: ExportedWalkers):
        """
        Update the values tracked by the walker if the passed \
        :class:`ExternalWalkers` contain  a better value.

        Args:
            walkers: The current best values will be compared against the \
                     walkers of this instance of :class:`ExportedWalkers`.

        Returns:
            None

        """
        curr_best = self.get_best_reward(self.minimize)
        other_best = walkers.get_best_reward(self.minimize)
        other_improves = curr_best > other_best if self.minimize else curr_best < other_best
        if other_improves:
            ix = walkers.get_best_index(self.minimize)
            self.states = copy.deepcopy(walkers.states[ix])
            self.observs = copy.deepcopy(walkers.observs[ix])
            self.rewards = copy.deepcopy(walkers.rewards[ix])
            self.id_walkers = copy.deepcopy(walkers.id_walkers[ix])


class ExportSwarm(SwarmWrapper):
    """Wrapper that allows to import and export data from :class:`ExportedWalkers`."""

    def __init__(
        self,
        swarm: Swarm,
        n_import: int = 2,
        n_export: int = 2,
        export_best: bool = True,
        import_best: bool = True,
    ):
        """
        Initialize a :class:`ExportSwarm`.

        Args:
            swarm: :class:`Swarm` that will be wrapped.
            n_import: Number of walkers that will be imported from an external \
                      :class:`ExportedWalkers`.
            n_export: Number of walkers that will be exported as :class:`ExportedWalkers`.
            export_best: The best walkers of the :class:`Swarm` will always be exported.
            import_best: The best walker of the imported :class:`ExportedWalkers` \
                         will be compared to the best walkers of the \
                         :class:`Swarm`. If it improves the current best value \
                         found, the best walker of the :class:`Swarm` will be updated.

        """
        self.n_import = n_import
        self.n_export = n_export
        self._export_best = export_best
        self._import_best = import_best
        super(ExportSwarm, self).__init__(swarm, name="swarm")

    def run_exchange_step(self, walkers: ExportedWalkers) -> ExportedWalkers:
        """
        Import the target :class:`ExportedWalkers` before iterating the wrapped \
        :class:`Swarm`, and export the target number of walkers as a \
        :class:`ExportedWalkers` class.

        Args:
            walkers: Walkers that will be imported after running an iteration \
            of the :class:`Swarm`.

        Returns:
            walkers exported after running an iteration of the :class:`Swarm`.

        """
        self.import_walkers(walkers)
        self.run_step()
        return self.export_walkers()

    def export_walkers(self) -> ExportedWalkers:
        """
        Export the number of walkers defined by ``self.n_export`` chosen at \
        random from the :class:`Swarm` walkers. If ``self.export_best`` is true \
        the best walker of the :class:`Swarm` will always be included.
        """
        if self.swarm.walkers.env_states.oobs.all():  # Do not export dead walkers
            return ExportedWalkers(batch_size=0)
        indexes = self._get_export_index()
        walkers = self._create_export_walkers(indexes)
        return walkers

    def import_walkers(self, walkers: ExportedWalkers) -> None:
        """
        Import the target :class:`ExportedWalkers` into the walkers of the :class:`Swarm`.

        The importing process will be done cloning ``self.n_import`` walkers \
        chosen at random after comparing them to the imported walkers. This will \
        be done running the FractalAI cloning operation.

        If ``self.import_best`` is ``True``, the best walker of the imported \
        walkers will be compared against the current best walker and update if \
        it improves the current best value found.

        Args:
            walkers: :class:`ExportedWalkers` that will be imported into the \
                    :class:`Swarm` pool of walkers.

        Returns:
            None.

        """
        if len(walkers) == 0:  # Do not import dead walkers
            return
        self.merge_walkers(walkers)
        if self._import_best:
            self.import_best(walkers)

    def merge_walkers(self, walkers: ExportedWalkers):
        """
        Perform a FractalAI clone operation between a random sample of the \
        :class:`Swarm` walkers and the imported walkers.

        Args:
            walkers: Walkers that will be imported. The :class:`Swarm` walkers \
                    can clone to them.

        Returns:
            None.

        """
        local_ix, import_ix = self._get_merge_indexes(walkers)
        compas_ix, will_clone = self._cross_fai_iteration(local_ix, import_ix, walkers)
        self._clone_to_imported(compas_ix, will_clone, local_ix, import_ix, walkers)

    def import_best(self, walkers: ExportedWalkers):
        """
        Import the best walker from the target :class:`ExportedWalkers` if it \
        improves the best value present in the :class:`Swarm`' walkers.

        Args:
            walkers: Walkers containing the best walker that will be imported \
                    if it improves the current best value found.

        Returns:
            None.

        """
        if self._imported_best_is_better(walkers):
            best_ix = walkers.get_best_index(self.swarm.walkers.minimize)
            # TODO (guillemdb): Check if deepcopy is really necessary
            best_reward = copy.deepcopy(walkers.rewards[best_ix])
            best_state = copy.deepcopy(walkers.states[best_ix])
            best_obs = copy.deepcopy(walkers.observs[best_ix])
            best_id = copy.deepcopy(walkers.id_walkers[best_ix])
            self.swarm.walkers.states.update(
                best_reward=best_reward, best_state=best_state, best_obs=best_obs, best_id=best_id
            )
            self.swarm.walkers.fix_best()

    def _get_export_index(self) -> numpy.ndarray:
        """Get an index of the walkers that will be exported."""
        index = self.swarm.walkers.get_in_bounds_compas()[: self.n_export]
        if self._export_best:  # Force the best to be present if needed.
            best_ix = self.swarm.walkers.get_best_index()
            if best_ix not in index:
                index[0] = best_ix
        return index

    def _create_export_walkers(self, indexes: numpy.ndarray) -> ExportedWalkers:
        """Create the :class:`ExportedWalkers` containing the walkers that will be exported."""
        states = self.swarm.walkers.env_states.states[indexes]
        observs = self.swarm.walkers.env_states.observs[indexes]
        rewards = self.swarm.walkers.states.cum_rewards[indexes]
        id_walkers = self.swarm.walkers.states.id_walkers[indexes]
        state_dict = self.swarm.env.get_params_dict()
        state_dict.update(self.swarm.walkers.states.get_params_dict())
        walkers = ExportedWalkers(batch_size=len(indexes), state_dict=state_dict)
        walkers.update(states=states, observs=observs, rewards=rewards, id_walkers=id_walkers)
        return walkers

    def _imported_best_is_better(self, walkers: ExportedWalkers) -> bool:
        """Check if the imported walkers improves the current best value of the :class:`Swarm`."""
        minim = self.swarm.walkers.minimize
        improves = (
            self.swarm.best_reward > walkers.get_best_reward(minim)
            if minim
            else self.swarm.best_reward < walkers.get_best_reward(minim)
        )
        return improves

    def _clone_to_imported(
        self,
        compas_ix: numpy.ndarray,
        will_clone: numpy.ndarray,
        local_ix: numpy.ndarray,
        import_ix: numpy.ndarray,
        walkers: ExportedWalkers,
    ) -> None:
        """Clone the :class:`Swarm` selected walkers to the target imported walkers."""
        clone_ids = copy.deepcopy(walkers.id_walkers[import_ix][compas_ix][will_clone])
        clone_rewards = copy.deepcopy(walkers.rewards[import_ix][compas_ix][will_clone])
        clone_states = copy.deepcopy(walkers.states[import_ix][compas_ix][will_clone])
        clone_obs = copy.deepcopy(walkers.observs[import_ix][compas_ix][will_clone])
        # TODO: Find a better way to do this. Assignment does not work after double array indexing
        i = 0
        for (ix, wc) in zip(local_ix, will_clone):
            if wc:
                self.swarm.walkers.states.id_walkers[ix] = clone_ids[i]
                self.swarm.walkers.states.cum_rewards[ix] = clone_rewards[i]
                self.swarm.walkers.env_states.states[ix] = clone_states[i]
                self.swarm.walkers.env_states.observs[ix] = clone_obs[i]
                i += 1

    def _get_merge_indexes(self, walkers: ExportedWalkers) -> Tuple[numpy.ndarray, numpy.ndarray]:
        """Get the indexes for selecting the walkers that will be compared in \
        the clone operation."""
        local_ix = random_state.choice(
            numpy.arange(len(self.swarm.walkers)), size=self.n_import, replace=False
        )
        if len(walkers) <= self.n_import:
            import_ix = random_state.choice(
                numpy.arange(len(walkers)), size=self.n_import, replace=False
            )
        else:
            import_ix = random_state.choice(
                numpy.arange(len(walkers)), size=self.n_import, replace=True
            )
        return local_ix, import_ix

    def _cross_fai_iteration(
        self, local_ix: numpy.ndarray, import_ix: numpy.ndarray, walkers: ExportedWalkers
    ) -> Tuple[numpy.ndarray, numpy.ndarray]:
        """Perform a cloning process of the walkers of the :class:`Swarm` \
        to the imported walkers."""
        local_obs = self.swarm.walkers.env_states.observs[local_ix]
        local_rewards = self.swarm.walkers.states.cum_rewards[local_ix]
        local_oobs = self.swarm.walkers.env_states.oobs[local_ix]
        import_obs = walkers.observs[import_ix]
        import_rewards = walkers.rewards[import_ix]
        compas_ix, will_clone = cross_fai_iteration(
            host_observs=local_obs,
            host_rewards=local_rewards,
            host_oobs=local_oobs,
            ext_observs=import_obs,
            ext_rewards=import_rewards,
            dist_coef=self.swarm.walkers.distance_scale,
            reward_coef=self.swarm.walkers.reward_scale,
            distance_function=self.swarm.walkers.distance_function,
        )
        return compas_ix, will_clone


class ParamServer:
    """
    Parameter server that stores the :class:`ExportedWalkers` generated by \
    different :class:`ExportSwarm`.

    It allows different :class:`ExportSwarm` to exchange walkers, and it keeps \
    track of the best walker found during the search process.
    """

    def __init__(self, max_len: int = 20, minimize: bool = False, add_global_best: bool = True):
        """
        Initialize a :class:`ParamServer`.

        Args:
            max_len: Maximum number of :class:`ExportedWalkers` that the \
                     :class:`ParamServer` will keep in its buffer.
            minimize: ``True`` if the :class:`ParamServer` will be used for a \
                       minimization process, ``False`` if it will be used for a \
                       maximization process.
            add_global_best: Add the best value found during the search to all \
                             the exported walkers that the :class:`ParamServer` \
                             returns.

        """
        self._max_len = max_len
        self.add_global_best = add_global_best
        self.minimize = minimize
        self.buffer = deque([], self._max_len)
        self.best = BestWalker(minimize=self.minimize)

    def __len__(self) -> int:
        """Return the length of the internal buffer."""
        return len(self.buffer)

    @property
    def max_len(self) -> int:
        """Return the maximum length of the internal buffer."""
        return self._max_len

    def reset(self):
        """Erase the internal data of the :class:`ParamServer`."""
        self.buffer = deque([], self._max_len)
        self.best = BestWalker(minimize=self.minimize)

    def exchange_walkers(self, walkers: ExportedWalkers) -> ExportedWalkers:
        """
        Store a new instance of :class:`ExportedWalkers` and return on of the \
        walkers stored in the internal buffer.

        If ``self.add_global_best`` is ``True`` the best walker found will be \
        included in the returned :class:`ExportedWalkers`.

        Args:
            walkers: Data that will be stored in the internal buffer.

        Returns:
            :class:`ExportedWalkers` sampled randomly from the internal buffer.

        """
        self.import_walkers(walkers)
        if len(self) == 0:
            return ExportedWalkers(0)
        return self.export_walkers()

    def import_walkers(self, walkers: ExportedWalkers):
        """
        Insert a the target :class:`ExportedWalkers` at the end of the internal \
        buffer and keep track of the best reward found.

        Args:
            walkers: Will be appended at the end of the internal buffer.

        Returns:
            None.

        """
        self._track_best_walker(walkers)
        new_walkers = copy.deepcopy(walkers)
        self.buffer.append(new_walkers)

    def export_walkers(self) -> ExportedWalkers:
        """
        Return a :class`ExportedWalkers` sampled randomly from the internal \
        buffer.

        If ``self.add_global_best`` is ``True`` the best walker found will be \
        included in the returned :class:`ExportedWalkers`.
        """

        index = random_state.randint(0, len(self))
        walkers = self.buffer[index]
        if self.add_global_best:
            walkers = self._add_best_to_exported(walkers)
        return walkers

    def _track_best_walker(self, walkers: ExportedWalkers):
        """Update the best value found and store it inside the internal \
        :class:`BestWalker`."""
        self.best.update_best(walkers=walkers)

    def _add_best_to_exported(self, walkers: ExportedWalkers) -> ExportedWalkers:
        """Override randomly one walker of the target :class:`ExportedWalkers` \
        with the best walker found."""
        index = random_state.randint(0, len(walkers))
        walkers.rewards[index] = self.best.rewards
        walkers.id_walkers[index] = self.best.id_walkers
        walkers.observs[index] = self.best.observs
        walkers.states[index] = self.best.states
        return walkers
